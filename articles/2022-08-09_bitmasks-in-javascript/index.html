<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Bitmasks in JavaScript: A Computer Science Crash Course | andy-blum.com</title><style>:where(:not(html,iframe,canvas,img,svg,video,audio):not(svg *,symbol *)){all:unset;display:revert}*,::after,::before{box-sizing:border-box}a,button{cursor:revert}:is(ol,ul):not(.plain){list-style:initial;list-style-position:inside}:is(ol,ul,menu).plain,nav :is(ol,ul,menu):not(.plain){list-style:none}img{max-inline-size:100%;max-block-size:100%}table{border-collapse:collapse}input,textarea{-webkit-user-select:auto}textarea{white-space:revert}meter{-webkit-appearance:revert;appearance:revert}:where(pre){all:revert}::placeholder{color:unset}::marker{content:initial}:where([hidden]){display:none}:where([contenteditable]:not([contenteditable=false])){-moz-user-modify:read-write;-webkit-user-modify:read-write;overflow-wrap:break-word;-webkit-line-break:after-white-space;-webkit-user-select:auto}:where([draggable=true]){-webkit-user-drag:element}:where(dialog:modal){all:revert}:root{--dark:#2a2a2a;--light:#eee;--white:#fff;--accent:#0076D1}@media (prefers-color-scheme:dark){:root{--dark:#ddd;--light:#333;--white:#111;--accent:#1A9CFF}}header{width:900px;max-width:calc(100% - 2em);margin:0 auto;padding:2em 0;display:flex;flex-wrap:wrap;justify-content:space-between}header nav ul{display:flex;gap:1em}header::after{content:'';display:block;height:5px;border-radius:999px;background-color:var(--accent);flex:1 1 100%;margin-top:1em}main{width:900px;margin:0 auto;max-width:calc(100% - 2em)}.visually-hidden:not(:focus){position:absolute!important;overflow:hidden;clip:rect(1px,1px,1px,1px);width:1px;height:1px;word-wrap:normal}img,picture,picture source{max-width:100%;height:auto;border-radius:7px}.post-preview{margin:0 0 1rem;padding:1rem;border:1px solid var(--dark);border-radius:4px}.post-preview .post-title{display:block;font-size:1.25rem}.post-preview .post-date{display:block}.pagination ul{display:flex;gap:1rem;justify-content:center}@font-face{font-family:Recursive;font-style:oblique 0deg 15deg;font-weight:300 1000;font-display:swap;src:url('/assets/recursive.woff2') format('woff2')}html{background:var(--white);color:var(--dark);font-family:Recursive,sans-serif;font-weight:400;font-variation-settings:'MONO' 0,'slnt' 0,'CRSV' 0;font-size:18px;line-height:1.75}*+:is(
h1,h2,h3,h4,h5,h6,p,blockquote,pre,fieldset,form,table,article,details,figure,audio,video,iframe,.highlighter-rouge,ol,ul
){margin-top:1em}:is(h1,h2,h3,h4,h5,h6){font-variation-settings:'wght' 800,'slnt' -15,'CRSV' 0;line-height:1.25}:is(h1,h2,h3,h4,h5,h6):not(:last-child){margin-bottom:1em}h1{font-size:2.5em}h2{font-size:2em}h3{font-size:1.75em}h4{font-size:1.5em}h5{font-size:1.1em}h6{font-size:1em}a{color:var(--accent);text-decoration:none}a:is(:hover,:focus){text-decoration:underline}strong{font-weight:bolder}small{font-size:.85em}svg{fill:currentColor;height:1em;width:1em}pre{font-size:inherit;display:block;position:relative;margin-left:auto;margin-right:auto;margin-bottom:2.5em;max-width:80ch;font-family:Recursive,monospace;line-height:1.5;font-variation-settings:'wght' 300;font-size:15px;background:#111;border:2px solid #555;border-top:none;color:#fff;padding:0;border-radius:10px;overflow:hidden;box-shadow:0 5px 10px 5px rgba(0,0,0,.3)}pre code{display:block;width:100%;overflow-x:scroll;padding:1em;background-color:transparent}pre code.hljs{background:inherit;color:inherit;padding:1em}pre:before{content:'';display:block;background:#555;width:100%;height:1.5em;border-radius:10px 10px 0 0}pre:after{content:'';display:block;position:absolute;top:.8em;left:.75em;transform:translateY(-50%);width:.75em;height:.75em;background:#f08080;border-radius:50%;box-shadow:1.1em 0 0 0 #daa520,2.2em 0 0 0 #3cb371}code{font-family:Recursive,monospace;font-variation-settings:"MONO" 1,"wght" 300;background-color:var(--light);padding:0 .25em}</style><link rel="stylesheet" href="/assets/highlight.min.css"></head><body><a class="visually-hidden" href="#main-content">Skip to the main content</a><header role="banner" class="site-head"><nav class="" aria-label="Site Navigation"><ul class="nav__list"><li><a href="/">Home</a></li><li><a href="/articles/" data-state="active">Articles</a></li><li><a href="/talks/">Talks</a></li><li><a href="/media/">Media</a></li></ul></nav><nav><ul><li><a rel="me" href="https://github.com/andy-blum/"><span class="visually-hidden">Github</span> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li><li><a rel="me" href="https://www.drupal.org/u/andy-blum"><span class="visually-hidden">Drupal</span> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M319.5 114.7c-22.2-14-43.5-19.5-64.7-33.5-13-8.8-31.3-30-46.5-48.3-2.7 29.3-11.5 41.2-22 49.5-21.3 17-34.8 22.2-53.5 32.3C117 123 32 181.5 32 290.5 32 399.7 123.8 480 225.8 480 327.5 480 416 406 416 294c0-112.3-83-171-96.5-179.3zm2.5 325.6c-20.1 20.1-90.1 28.7-116.7 4.2-4.8-4.8.3-12 6.5-12 0 0 17 13.3 51.5 13.3 27 0 46-7.7 54.5-14 6.1-4.6 8.4 4.3 4.2 8.5zm-54.5-52.6c8.7-3.6 29-3.8 36.8 1.3 4.1 2.8 16.1 18.8 6.2 23.7-8.4 4.2-1.2-15.7-26.5-15.7-14.7 0-19.5 5.2-26.7 11-7 6-9.8 8-12.2 4.7-6-8.2 15.9-22.3 22.4-25zM360 405c-15.2-1-45.5-48.8-65-49.5-30.9-.9-104.1 80.7-161.3 42-38.8-26.6-14.6-104.8 51.8-105.2 49.5-.5 83.8 49 108.5 48.5 21.3-.3 61.8-41.8 81.8-41.8 48.7 0 23.3 109.3-15.8 106z"/></svg></a></li><li><a rel="me" href="https://drupal.community/@andy_blum"><span class="visually-hidden">Mastodon</span> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg></a></li><li><a rel="me" href="https://www.linkedin.com/in/andyblum/"><span class="visually-hidden">LinkedIn</span> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z"/></svg></a></li></ul></nav></header><main tabindex="-1" id="main-content"><article><h1>Bitmasks in JavaScript: A Computer Science Crash Course</h1><p>One of the nice things about front-end web development as a career choice is that the software and coding languages are available on every modern machine. It doesn’t matter what operating system or how powerful your machine is. HTML, CSS, and JavaScript will run <em>pretty well</em> on it. This lets a lot of us in the industry bypass the need for formal education in computer science.</p><p>Unfortunately, this also has the side effect of leaving little gaps in our knowledge here and there, especially in strategies like bitmasking, which are seldom used in web development.</p><h2>What is a bitmask?</h2><p>Bitmasking is a strategy that can be used to store multiple true-or-false values together as a single variable. Depending on the language, this can be more memory efficient and also opens up the doors to some special operators that we’ll look at later. This trick takes advantage of two simple facts:</p><ul><li>humans and computers look at numbers differently.</li><li>the way computers think about numbers is identical to how they think about true and false.</li></ul><p>Humans typically think of numbers in a decimal, or base-10, system. We have 10 unique digits of 0-9, and when we want to count beyond 9, we create new columns as needed to symbolize how many multiples of ten, one hundred, one thousand, (the powers of ten), and so on we need. Computers, on the other hand, look at numbers in a <a href="https://code.tutsplus.com/articles/number-systems-an-introduction-to-binary-hexadecimal-and-more--active-10848">binary or base-2 system</a>. Computers have 2 unique digits, 0 or 1, and when they need to count beyond that, they create new columns to symbolize how many multiples of 2, 4, or 8 (the powers of two) <em>they</em> need. While we think of numbers differently, the values of integers are ultimately identical, and the computer stores all numbers as binary values. Each individual binary digit is a <em>bit</em> of information.</p><table><thead><tr><th>English</th><th>Base-10</th><th>Base-2</th></tr></thead><tbody><tr><td>Zero</td><td>0</td><td>0</td></tr><tr><td>One</td><td>1</td><td>1</td></tr><tr><td>Two</td><td>2</td><td>10</td></tr><tr><td>Three</td><td>3</td><td>11</td></tr><tr><td>Four</td><td>4</td><td>100</td></tr><tr><td>Five</td><td>5</td><td>101</td></tr><tr><td>Six</td><td>6</td><td>110</td></tr><tr><td>Seven</td><td>7</td><td>111</td></tr><tr><td>Eight</td><td>8</td><td>1000</td></tr><tr><td>Nine</td><td>9</td><td>1001</td></tr><tr><td>Ten</td><td>10</td><td>1010</td></tr></tbody></table><p>When we combine the fact that all our numbers are converted to binary for storage with the fact that boolean true/false values are also stored as a 1 or 0, respectively, we can see how we could easily store a group of boolean values as a single integer. All we have to do is make sure each value we care about is stored as a separate power of two.</p><h2>Where might I see this?</h2><p>A great example of this in front-end development is the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition">Node.compareDocumentPosition</a> method. This method compares the relative positioning between two nodes on a page and returns a bitmask of the resulting comparison. There are six possible values of <code>a.compareDocumentPosition(b)</code></p><ul><li>Disconnected - These nodes are not in the same document tree (for example, one node is in a web component’s <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">shadow DOM</a>)</li><li>Preceding - Node a follows node b in the document tree.</li><li>Following - Node b follows node a in the document tree.</li><li>Contains - Node a is a descendant of node b.</li><li>Contained By - Node a is an ancestor of node b.</li><li>Implementation Specific - This rarely means anything to us and is an artifact of how the calculation is done within the browser.</li></ul><p>The result of our comparison could yield any combination of those 6 being true or false, a potential 64 unique combinations! The way we make sense of this, however, is to assign each value a bit. Since we have 6 values, we’ll need six bits.</p><table><thead><tr><th>Result</th><th>Base-10</th><th>Base-2</th></tr></thead><tbody><tr><td>Disconnected</td><td>1</td><td>000001</td></tr><tr><td>Preceding</td><td>2</td><td>000010</td></tr><tr><td>Following</td><td>4</td><td>000100</td></tr><tr><td>Contains</td><td>8</td><td>001000</td></tr><tr><td>Contained By</td><td>16</td><td>010000</td></tr><tr><td>Implementation Specific</td><td>32</td><td>100000</td></tr></tbody></table><p>Now our 64 possible combinations can be numbered from 0 (all are false) to 63 (all are true). Of course, not <em>all</em> combinations are actually possible, as nodes can neither precede <em>and</em> follow nor contain <em>and</em> be contained by. Nevertheless, when we examine the returned number bit-by-bit, we can tell exactly which values are true and which are false.</p><h2>How do I use this?</h2><p>One great use of this is in <a href="https://github.com/carbon-design-system/carbon-for-ibm-dotcom/blob/3bb5f39f7e773ff10b8ac7a35461549ade07dd45/packages/web-components/src/components/expressive-modal/expressive-modal.ts">the focus-trapping logic in IBM’s Carbon Design System</a>. Since we want to prevent focus from leaving the modal and instead loop it back into the element, we have a <code>focusout</code> event listener on the modal’s container element. When focus leaves an element within the modal, the <code>focusout</code> event bubbles up, and we’re able to see the event’s target element that just lost focus, as well as the event’s <code>relatedTarget</code> element that just gained focus. We can then compare the positioning of the <code>relatedTarget</code> to the modal container, and if the “contains” value is not true, we know we need to force focus back into the modal.</p><p><img src="/sites/default/files/styles/max_1300x1300/public/2022-08/ktprgcsa.png?itok=xWIaok0o" alt="Diagram showing how focus is able to move between the elements within a modal, and is forced to wrap between the first and last focusable items when attempting to move focus out of the modal’s containing element."></p><p>While we could split out the bits and do individual comparisons, JavaScript has <a href="https://www.w3schools.com/js/js_bitwise.asp"><em>bitwise operators</em></a> designed specifically to compare two bitmasks and yield a third bitmask. These operators will compare each individual bit and then yield a 0 or a 1.</p><ul><li>&amp; will evaluate to 1 when two compared bits are <em>both</em> 1</li><li>| will evaluate to 1 when either compared bit is 1</li><li>^ will evaluate to 1 when one, but not both, compared bits are 1.</li></ul><p>Try comparing 5 and 9 with each operator in this truth table to see bitwise calculations in action:</p><p>See the Pen Bitwise Calculator by Andy Blum (@andy-blum) on CodePen.</p><p><a href="https://codepen.io/andy-blum/pen/ExEajpX">https://codepen.io/andy-blum/pen/ExEajpX</a></p><p>Once we understand these comparison operations, we can use them within our code. We’ll start by creating the combination flags <code>PRECEDING</code> and <code>FOLLOWING</code>. These new flags combine the bitmasks provided by the <code>Node</code> object. In our use case, <code>PRECEDING</code> will indicate that the compared node’s tab order should be prior to the current node and <code>FOLLOWING</code> will indicate the opposite. We’ll also create a bitmask <code>WITHIN</code> that will be easier to read in our code later.</p><pre><code class="language-js">const PRECEDING = Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS;
const FOLLOWING = Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY;
const WITHIN = Node.DOCUMENT_POSITION_CONTAINED_BY;
</code></pre><p>Next, within our <code>focusout</code> event listener, we can compare the relative positions of the event’s <code>target</code>, which just lost focus and its <code>relatedTarget</code>, which just gained focus. The code below has been modified slightly from the source to make it easier to read and has comments pointing to the breakdown below.</p><pre><code class="language-js">function handleFocusOut(event) {
  const { target, relatedTarget } = event;

  // #1
  const positionToModal =
    this.compareDocumentPosition(relatedTarget) |
    (this.shadowRoot?.compareDocumentPosition(relatedTarget) || 0);

  // #2
  const positionToPrevious = target.compareDocumentPosition(relatedTarget);

  // #3
  const relatedTargetIsContained = Boolean(positionToModal &amp; WITHIN);

  // #4
  if (!relatedTargetIsContained &amp;&amp; !(relatedTarget === this)) {

    // #5a
    if (positionToPrevious &amp; PRECEDING) {
      // #6a
      tryFocusElems(focusableElements as [HTMLElement], true, this);

    // #5b
    } else if (positionToPrevious &amp; FOLLOWING) {
      // #6b
      tryFocusElems(focusableElements as [HTMLElement], false, this);
    }
  }
};
</code></pre><p>Let’s break it down:</p><ol><li>We create a bitmask variable, <code>positionToModal</code>. This is a combination of the comparison between the modal and the <code>relatedTarget</code> as well as the modal’s shadowroot and the <code>relatedTarget</code>. The element we’ve focused to could be in either the regular document or in the Shadow DOM, so we want to compile both comparisons together.</li><li>We create a bitmask variable, <code>positionToPrevious</code>. This is the comparison of the target and the related target.</li><li>We create a boolean variable, <code>relatedTargetIsContained</code>. This compares <code>positionToModal</code> and <code>WITHIN</code>. If the element we focused on is in any way <em>inside our modal</em>, then this variable is true.</li><li>We check to see if our <code>relatedTarget</code> is contained within the modal and that our <code>relatedTarget</code> is not the modal itself. If that’s true, then we know our <code>relatedTarget</code> is <em>outside</em> the modal, and we need to redirect focus.</li><li>We compare our <code>positionToPrevious</code> bitmask with our <code>PRECEDING</code> and <code>FOLLOWING</code>  bitmasks. If they overlap, then we know which way to try to focus, and we use our <code>tryFocusElems</code> function to move focus back into the modal.</li><li>The <code>tryFocusElems</code> function systematically attempts to place focus on each element in <code>elems</code>. It can run in forward or reverse order based on the second argument, and if none of the elements provided will hold focus, it falls back to the element provided in the third argument</li></ol><h2>Conclusion</h2><p>Bitmasks and bitwise operations are not strategies front-end developers are likely to reach for often, but having a solid foundation of computer science principles can help us to know when they are the right tool to use. Understanding the theory behind <a href="https://code.tutsplus.com/articles/number-systems-an-introduction-to-binary-hexadecimal-and-more--active-10848">how numbering systems work</a> and <a href="https://www.w3schools.com/js/js_bitwise.asp">how computers can compare and manipulate masks</a> can open up new opportunities in our code.</p></article></main><script src="/assets/highlight.min.js"></script></body></html>